import { Router, Request, Response } from 'express';
import RegisterService from '../services/register.service';
import UserEntity from '../entities/user.entity';
import bcrypt from 'bcrypt';
import { validateCep, validateEmail, validatePassword, validateRequiredFields } from '../utils/validation/validation';
import { ValidationMessages } from '../utils/validation/validationMessages';
import { HttpBadRequestError, HttpNotFoundError } from '../utils/errors/http.error';
import { FailureResult, Result, SuccessResult } from '../utils/result';

class RegisterController {
  private prefix: string = '/register';
  public router: Router;
  private registerService: RegisterService;

  constructor(router: Router, registerService: RegisterService) {
    this.router = router;
    this.registerService = registerService;
    this.initRoutes();
  }

  private initRoutes() {
    this.router.post(this.prefix, (req: Request, res: Response) => this.createUser(req, res));
    this.router.get(this.prefix, (req: Request, res: Response) => this.getUsers(req, res));
    this.router.get(`${this.prefix}/:id`, (req: Request, res: Response) => this.getUser(req, res));
    this.router.put(`${this.prefix}/:id`, (req: Request, res: Response) => this.updateUser(req, res));
    this.router.delete(`${this.prefix}/:id`, (req: Request, res: Response) => this.deleteUser(req, res));
  }

  private async createUser(req: Request, res: Response) {
    const { name, email, gender, paymentMethod, cpf, cep, password, recoveryQuestion } = req.body;

    const fieldsToValidate = { name, email, gender, paymentMethod, cpf, cep, password, recoveryQuestion };

    if (!validateRequiredFields(fieldsToValidate)) {
      return new FailureResult({
        msg: ValidationMessages.REQUIRED_FIELDS,
        code: 400
      }).handle(res);
    }

    if (!validateCep(cep)) {
      return new FailureResult({
        msg: ValidationMessages.INVALID_CEP,
        code: 400
      }).handle(res);
    }

    if (!validateEmail(email)) {
      return new FailureResult({
        msg: ValidationMessages.INVALID_EMAIL,
        code: 400
      }).handle(res);
    }

    if (!validatePassword(password)) {
      return new FailureResult({
        msg: ValidationMessages.INVALID_PASSWORD,
        code: 400
      }).handle(res);
    }

    try {
      const hashedPassword = await bcrypt.hash(password, 10); // hash the password

      const newUser = await this.registerService.createUser(new UserEntity({
        id: '', // id will be generated by the service
        name,
        email,
        gender,
        paymentMethod,
        cpf,
        cep,
        password: hashedPassword, // use the hashed password
        recoveryQuestion,
      }));

      return new SuccessResult({
        msg: ValidationMessages.USER_CREATED_SUCCESS,
        data: newUser,
      }).handle(res);
    } catch (error) {
      const msgCode = (error as HttpBadRequestError).msgCode;
      if (msgCode === ValidationMessages.EMAIL_ALREADY_EXISTS) {
        return new FailureResult({
          msg: ValidationMessages.EMAIL_ALREADY_EXISTS,
          code: 400
        }).handle(res);
      }

      if (msgCode === ValidationMessages.CPF_ALREADY_EXISTS) {
        return new FailureResult({
          msg: ValidationMessages.CPF_ALREADY_EXISTS,
          code: 400
        }).handle(res);
      }

      return new FailureResult({
        msg: ValidationMessages.UNEXPECTED_ERROR,
        code: 500,
      }).handle(res);
    }
  }

  private async getUsers(req: Request, res: Response) {
    try {
      const users = await this.registerService.getUsers();
      return new SuccessResult({
        msg: Result.transformRequestOnMsg(req),
        msgCode: ValidationMessages.USERS_RETRIEVED_SUCCESS,
        data: users,
      }).handle(res);
    } catch (error) {
      return new FailureResult({
        msg: ValidationMessages.UNEXPECTED_ERROR,
        code: 500,
      }).handle(res);
    }
  }

  private async getUser(req: Request, res: Response) {
    try {
      const user = await this.registerService.getUser(req.params.id);
      return new SuccessResult({
        msg: ValidationMessages.USER_RETRIEVED_SUCCESS,
        data: user,
      }).handle(res);
    } catch (error) {
      const { msg } = error as HttpNotFoundError;
      return new FailureResult({
        msg,
        code: 404,
      }).handle(res);
    }
  }

  private async updateUser(req: Request, res: Response) {
    try {
      const updatedUser = await this.registerService.updateUser(req.params.id, new UserEntity(req.body));
      return new SuccessResult({
        msg: ValidationMessages.USER_UPDATED_SUCCESS,
        data: updatedUser,
      }).handle(res);
    } catch (error) {
      if (error instanceof HttpNotFoundError) {
        return new FailureResult({
          msg: error.message,
          code: 404,
        }).handle(res);
      } else if (error instanceof HttpBadRequestError) {
        return new FailureResult({
          msg: error.message,
          code: 400,
        }).handle(res);
      } else {
        return new FailureResult({
          msg: ValidationMessages.UNEXPECTED_ERROR,
          code: 500,
        }).handle(res);
      }
    }
  } 

  private async deleteUser(req: Request, res: Response) {
    try {
      await this.registerService.deleteUser(req.params.id);
      return new SuccessResult({
        msg: ValidationMessages.USER_DELETED_SUCCESS,
      }).handle(res);
    } catch (error) {
      const { msg } = error as HttpNotFoundError;
      return new FailureResult({
        msg,
        code: 404,
      }).handle(res);
    }
  }
}

export default RegisterController;
